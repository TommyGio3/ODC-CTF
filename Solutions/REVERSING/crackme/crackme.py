# Dobbiamo ricavare la key che si trova nella funzione catch_function che viene chiamata all'inizio del main
'''
  for (local_3c = 0; key1[local_3c] != '\0'; local_3c = local_3c + 1) {
    if ((*(byte *)(local_3c + input) ^ key1[local_3c]) != (&DAT_00100980)[local_3c]) {
      bVar1 = false;
    }
  }

  In questa for viene fatto uno xor tra la key e il nostro input(flag) e per andare bene deve dare come risultato DAT_00100980
  Quindi basta fare lo xor tra la key e DAT_00100980 per ottenere il giusto input (flag)
  Per ottenere i valori di DAT_00100980 basta cliccarci sopra e sono quelli in colonna mentre per ottenere
  quelli di key ci si clicca sopra poi vicino a key c'è addr DAT_00100958, si clicca sopra quello e rimanda ai valori in colonna
'''
xor = []
DAT_00100980 = [0x7f, 0xef, 0xe8, 0xb5, 0x15, 0x73, 0xb4, 0x6a, 0xa7, 0x7d, 0x48, 0xdd, 0xea, 0x6a, 0x9d, 0xaa, 0x82, 0xfa, 0x6e, 0xe4, 0xf6, 0x23, 0x9b, 0xd9, 0x78, 0xab, 0x1b, 0x9b, 0x16, 0x96, 0x9c, 0x2e, 0x6f, 0xb2, 0xc7, 0x0c, 0x17, 0x00, 0x00]
key = [0x19, 0x83, 0x89, 0xd2, 0x6e, 0x1f, 0x84, 0x1c, 0x94, 0x11, 0x31, 0x82, 0xde, 0x04, 0xe9, 0x9b, 0xf0, 0xc9, 0x18, 0xbb, 0x82, 0x51, 0xaa, 0xba, 0x13, 0x9e, 0x44, 0xec, 0x49, 0xe5, 0xad, 0x49, 0x01, 0x86, 0xab, 0x39, 0x6a, 0x00, 0x00, 0x00]
lunghezza_key = len(key)
lunghezza_DAT = len(DAT_00100980)
for i in range(len(key)):     
   if (key[i] == 0x00):          # '\0' in assembly è 0x00
      break
   xor.append(chr(key[i] ^ DAT_00100980[i]))
flag = ''.join(xor)
print(flag)
#print("DAT: ", lunghezza_DAT)
#print("KEY: ", lunghezza_key)